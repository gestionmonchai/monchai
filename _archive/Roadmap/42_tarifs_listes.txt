Roadmap 42 â€” /tarifs/listes (Listes de prix par segment/pays/devise/UOM) â€” VERSION DÃ‰TAILLÃ‰E
============================================================================================

ğŸ¯ Objectif
-----------
Mettre en place un systÃ¨me de **listes de prix versionnÃ©es** par segment/pays/devise/UOM avec **paliers de quantitÃ©**, 
**activation datÃ©e**, **fallbacks** et **import bulk**. La rÃ©solution doit Ãªtre constante en < 15 ms p50 cÃ´tÃ© service 
(avec caches chauds) et < 600 ms p95 pour les Ã©crans (10k items).

ğŸ“¦ ModÃ¨le de donnÃ©es (DDL suggÃ©rÃ©)
----------------------------------
- `price_list(id, org_id, code, name, segment ENUM, country_code?, currency CHAR(3), is_active bool, notes text, created_at, updated_at)`
  - UNIQUE(org_id, code)
  - INDEX(org_id, segment, country_code, is_active)

- `price_list_version(id, price_list_id, version_no INT, effective_from DATE, effective_to DATE NULL, status ENUM('draft','active','archived'), created_at)`
  - UNIQUE(price_list_id, version_no)
  - CHECK(effective_to IS NULL OR effective_to > effective_from)
  - INDEX(price_list_id, status, effective_from, effective_to)

- `price_item(id, price_list_version_id, cuvee_id, uom_id, min_qty INT DEFAULT 1, max_qty INT NULL, base_price NUMERIC(12,3), volume_eq_l NUMERIC(12,3) NOT NULL, notes TEXT NULL)`
  - UNIQUE(price_list_version_id, cuvee_id, uom_id, min_qty)
  - INDEX(price_list_version_id, cuvee_id, uom_id, min_qty)
  - CHECK(base_price >= 0)
  - CHECK(min_qty >= 1)
  - CHECK(max_qty IS NULL OR max_qty >= min_qty)

- `price_list_assignment(id, price_list_id, segment ENUM NULL, country_code CHAR(2) NULL, default_for_segment BOOL DEFAULT false)`
  - But : dÃ©clarer oÃ¹ sâ€™applique une liste (segment/pays)
  - INDEX(org_id, segment, country_code, default_for_segment)

ğŸ“ RÃ¨gles & rÃ©solutions â€” PrioritÃ©s (du + spÃ©cifique au + gÃ©nÃ©rique)
--------------------------------------------------------------------
1) (segment + country) â†’ 2) (segment only) â†’ 3) (country only) â†’ 4) global par dÃ©faut (aucun filtre)
Puis version **active** Ã  la date `D`. Ensuite, item exact `(cuvee_id, uom_id, qty)` en respectant les paliers (min/max).

â›ï¸ Ã‰tapes dâ€™implÃ©mentation (intermÃ©diaires, trÃ¨s guidÃ©es)
---------------------------------------------------------
Ã‰tape 0 â€” Foundation
- [ ] Migrations DDL (tables + indexes + contraintes).
- [ ] Seed: 1 liste FR/Pro/EUR code `PL_PRO_FR`, `v1` draft avec 20 items de test.

Ã‰tape 1 â€” CRUD listes
- [ ] Endpoint `POST /tarifs/listes` : validation `currency` ISOâ€‘4217, `segment` cohÃ©rent, `code` unique.
- [ ] Endpoint `GET /tarifs/listes` : filtres segment/country/currency/active + pagination keyset `(updated_at,id)`.
- [ ] UI liste (cartes) : segment/pays/devise + statut + CTA â€œVoir/Ã‰diterâ€.

Ã‰tape 2 â€” Versions
- [ ] `POST /tarifs/listes/:id/versions` : crÃ©e `version_no` = max + 1, `status='draft'`.
- [ ] `GET /tarifs/listes/:id` : timelines, badge `active`, bouton â€œActiverâ€, â€œArchiverâ€.
- [ ] `POST /tarifs/listes/:id/versions/:v/activate?effective_from=YYYY-MM-DD`
      - Valide quâ€™aucune autre version **active** ne couvre cette date (chevauchement interdit).
      - Passe lâ€™ancienne active en `archived` si pÃ©riode rÃ©volue, sinon `effective_to = effective_from` de la nouvelle (selon policy).

Ã‰tape 3 â€” Items (bulk + inline)
- [ ] `POST /tarifs/listes/:id/versions/:v/items/bulk` (CSV/JSON)
      - Idempotence par `(cuvee_id,uom_id,min_qty)`
      - Conversions `volume_eq_l` obligatoires (0.75 pour 75 cL, 1.5 pour magnum, etc.).
- [ ] UI items : table avec inline edit (dblâ€‘click), import CSV, duplication de ligne, copier/coller prix.

Ã‰tape 4 â€” Assignments (portÃ©e)
- [ ] `POST /tarifs/listes/:id/assign` : {segment?, country_code?, default_for_segment?}
- [ ] RÃ©solution test (endpoint interne de debug): `GET /tarifs/listes/resolve?segment=...&country=...&date=...`
      - Retourne `{price_list_id, version_no}` choisi + source (prioritÃ©).

Ã‰tape 5 â€” Service de rÃ©solution (moteur listes)
- [ ] Fonction `resolve_price_list(org, segment, country, date)` :
      - RequÃªte ordonnÃ©e par prioritÃ© (SQL UNION ALL avec colonne `priority`) â†’ premier match
      - Cache Redis clÃ©: `pl:{org}:{segment}:{country}:{date_bucket}` (bucket = jour) TTL 300 s
- [ ] Fonction `resolve_price_item(version_id, cuvee_id, uom_id, qty)` :
      - `min_qty <= qty AND (max_qty IS NULL OR qty <= max_qty)` avec tri `min_qty DESC` (prend le plus grand palier applicable)

Ã‰tape 6 â€” Invalidations & ObservabilitÃ©
- [ ] Invalidation cache lors de : activation version, modification assignment, bulk items.
- [ ] Metrics:
      - `pricing_list_resolve_latency_ms` (histogramme), `cache_hit_ratio`, `price_items_count`
- [ ] Logs: `org, list_id, version_no, segment, country, matched_rule, item_id`

Ã‰tape 7 â€” SÃ©curitÃ© & robustesse
- [ ] RBAC: `editor+` CRUD ; `viewer` lecture.
- [ ] RLS org ; CSRF ; overposting whitelist ; validation devise cohÃ©rente avec org.

ğŸ§ª Tests dâ€™acceptation (AC)
---------------------------
- ACâ€‘42â€‘01 : CrÃ©ation liste FR/Pro/EUR, v1 draft + 100 items importÃ©s (CSV), paliers (1/6/12).
- ACâ€‘42â€‘02 : Activation v1 Ã  D â†’ rÃ©solution retourne v1 Ã  D+Îµ ; aucune version active chevauchÃ©e.
- ACâ€‘42â€‘03 : RÃ©solution client Pro FR â†’ item correct pour cuvÃ©e+UOM en fonction de qty (6 â†’ palier 6).
- ACâ€‘42â€‘04 : Fallback segment only si pas dâ€™affectation pays ; global si rien dâ€™autre.

ğŸ›¡ï¸ Robustesse (edge cases)
--------------------------
- Chevauchement dates â†’ rejet 422 avec message.
- `max_qty` < `min_qty` â†’ rejet 400.
- Conflit de `currency` entre listes pour un mÃªme scope â†’ autorisÃ© (politiques dâ€™orga), mais signalÃ© (warning observabilitÃ©).

ğŸ“š Documentation Dev Book
-------------------------
- `pricing_lists.md` (complet) : schÃ©mas, exemples, requÃªtes SQL de rÃ©solution, caches, invalidations, runbook dâ€™activation.
