Roadmap 43 â€” /tarifs/remises (RÃ¨gles par client/segment/cuvÃ©e â€” stacking/exclusive/stop) â€” VERSION DÃ‰TAILLÃ‰E
===========================================================================================================

ðŸŽ¯ Objectif
-----------
Mettre en place un **moteur de remises** flexible avec **prioritÃ©s**, **paliers quantitÃ©**, **pÃ©riodes**, **portÃ©es** (client/segment/global), 
et des **modes dâ€™empilement** (`stack`, `exclusive`, `stop`). Garantir la lisibilitÃ© des calculs (audit).

ðŸ“¦ ModÃ¨le (DDL suggÃ©rÃ©)
-----------------------
`discount_rule` :
- Colonnes : `scope ENUM('client','segment','global')`, `target_id?` (client_id ou segment), `cuvee_id?`, `family_id?`,
  `percent?` (0..100), `amount_off?` (>=0), `currency?`, `min_qty INT`, `effective_from`, `effective_to?`, 
  `priority INT`, `stack_mode ENUM('stack','exclusive','stop')`, `is_active bool`, `notes text`.
- Index : `(org, scope, target_id, cuvee_id, family_id, effective_from, effective_to, priority)`.

âš–ï¸ RÃ¨gles dâ€™application
-----------------------
- Filtrer les rÃ¨gles Ã©ligibles pour `{client, segment, cuvee, qty, date}` et `is_active=true`.
- Trier par `priority ASC, id ASC` (ordre stable).
- Appliquer :
  - `exclusive` : choisir **la meilleure** (max remise) et **stop**.
  - `stack` : appliquer successivement (pourcentages **multiplicatifs**) puis `amount_off` (dans la devise de la price_list).
  - `stop` : appliquer puis **stop**.
- `floor_price` (option) : prix minimal dÃ©fini au niveau `price_item` ou `cuvee` â€” couper la remise si on descend sous le plancher, marquer `flag_floor_hit`.

â›ï¸ Ã‰tapes dâ€™implÃ©mentation
--------------------------
Ã‰tape 0 â€” Base
- [ ] Migration `discount_rule` + index.
- [ ] Seeds : 3 rÃ¨gles (global -2% stack / segment Pro -5% stack / client X -12% exclusive).

Ã‰tape 1 â€” CRUD & Listing
- [ ] GET `/tarifs/remises` (filtres: client, segment, cuvÃ©e, effective, active)
- [ ] POST `/tarifs/remises` (validation: percent XOR amount_off, devise si amount_off).
- [ ] Disable/enable â†’ soft-toggle `is_active`.

Ã‰tape 2 â€” SÃ©lecteur de rÃ¨gles (service)
- [ ] `select_applicable_rules(org, client?, segment, cuvee?, qty, date)` :
      SQL paramÃ©trÃ© + UNION selon portÃ©e ; renvoie liste ordonnÃ©e prÃªte Ã  appliquer.

Ã‰tape 3 â€” Moteur dâ€™application
- [ ] `apply_discounts(base_price, rules[], currency)` :
      - Maintenir `price_after_each_step` pour audit.
      - Pour `percent`: `price = round(price * (1 - p/100), 3)` (HT).
      - Pour `amount_off`: `price = max(0, price - amount_off)` **dans la devise** de la liste.
      - GÃ©rer `exclusive` / `stop`.
      - Couper Ã  `floor_price` si dÃ©fini â†’ `flag_floor_hit=true`.

Ã‰tape 4 â€” ObservabilitÃ© & Caches
- [ ] Cache (trÃ¨s court, 60s) pour `select_applicable_rules` par `(segment, cuvee, qty_bucket, date_bucket)` + invalidations sur CRUD.
- [ ] Metrics : `discount_rules_applied_total`, `discounts_latency_ms`, `floor_hits_total`.
- [ ] Logs dâ€™audit : `rule_id, scope, priority, stack_mode, price_after`.

Ã‰tape 5 â€” UI/UX
- [ ] Table des rÃ¨gles : colonnes PortÃ©e, Cible, Produit, Paliers, PÃ©riode, Priority, Stack, Active.
- [ ] Inline edit (dblâ€‘click), duplication de rÃ¨gle, **simulateur local** (voir 45).

ðŸ§ª Tests dâ€™acceptation (AC)
---------------------------
- ACâ€‘43â€‘01 : Client X -12% `exclusive` **Ã©crase** -5% segment.
- ACâ€‘43â€‘02 : Stack -2% + -3% â†’ rÃ©sultat multiplicatif `1 - (0.98*0.97) = 4.94%` et pas 5% additif.
- ACâ€‘43â€‘03 : `min_qty=12` dÃ©clenche correctement au seuil.
- ACâ€‘43â€‘04 : FenÃªtre temporelle respecte `date` du document.

ðŸ›¡ï¸ Robustesse
--------------
- Devise `amount_off` â‰  devise price_list â†’ 422.
- Deux rÃ¨gles `exclusive` de prioritÃ© identique : choisir la **meilleure** remise puis stop (ordre stable `id`).
- `percent > 100` â†’ rejet 400 ; `amount_off < 0` â†’ rejet.

ðŸ“š Dev Book
-----------
- `discounts_engine.md` : pseudoâ€‘code, tableaux dâ€™exemples, schÃ©mas de prioritÃ©s, piÃ¨ges (double application), conseils.
